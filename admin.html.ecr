<html>
  <head>
    <script src="obs-websocket.js"></script>
    <script src="moment.js"></script>
    <script src="moment-duration-format.js"></script>

    <link rel="stylesheet" href="style.css">
  </head>

  <body>
    <div class="scene-manager">
      <h1>Scenes</h1>
      <p>Click a scene to transition to it on stream</p>
      <div class="available-scenes">
      </div>
    </div>

    <div id="checklist">
      <h2>Checklist</h2>
      <p>Make sure each of these things has been done before transitioning the stream scene.</p>
      <ol>
        <li>Runner is in Discord call</li>
        <li>Commentators (if any) are in Discord call</li>
        <li>Runner has started stream (check on VLC - reference <a href="https://pastebin.com/ULhTjDgE" target="_blank">this pastebin</a> for stream keys.</li>
        <li>Commentators have runner's stream up (again, reference above pastebin).</li>
        <li>Runner information is correct</li>
        <li>Current Game on Twitch has been updated</li>
      </ol>
    </div>

    <div class="timer-control">
      <h2>Timer Control</h2>
      <span class="timer-state"></span>
      <span class="timer-time">00:00:00</span>
      <div class="actions">
        <button id="start_timer">Start</button>
        <button id="stop_timer">Finish</button>
        <button id="reset_timer">Reset</button>
      </div>
    </div>
  </body>

  <script>
    const obs = new OBSWebSocket();
    connection = obs.connect({ address: '192.168.200.184:4444', password: 'spyrothon' });

    obs.onSwitchScenes(function(data) {
      console.log('New Active Scene:', data.sceneName);
    });

    connection.then(function() {
      obs.getSceneList({}).then(function(response) {
        response.scenes.forEach(function(scene) {
          var element = document.createElement("div");
          element.classList.add("scene");
          element.innerText = scene.name;
          document.querySelector(".available-scenes").appendChild(element);
          if(scene.name == response.currentScene) {
            element.classList.add("current-scene");
          }
        });
      });
    });


    document.addEventListener('click', function(event) {
      var target = event.target;
      if(!target.classList.contains("scene")) return;
      console.log(target);

      obs.setCurrentScene({ "scene-name": target.innerText });
    }, false);

    let base_uri = ((window.location.protocol === "https:") ? "wss://" : "ws://") + window.location.host;
    let timer_socket = new WebSocket(base_uri + "/timer-control");

    timer_socket.onmessage = function(event) {
      var msg = JSON.parse(event.data);

      switch(msg.type) {
        case "timer_start":

          break;
      }
    };

    function start_timer() {
      timer_socket.send('{"action": "start" }');
      document.querySelector(".timer-time").classList.add("updated-timer");
    }

    document.querySelector("#start_timer").addEventListener('click', this.start_timer.bind(this));

    function stop_timer() {
      timer_socket.send('{"action": "stop" }');
      document.querySelector(".timer-time").classList.remove("updated-timer");
    }

    document.querySelector("#stop_timer").addEventListener('click', this.stop_timer.bind(this));

    function reset_timer() {
      timer_socket.send('{"action": "reset" }');
      document.querySelector(".timer-time").classList.remove("updated-timer");
      document.querySelector(".timer-time").innerText = '00:00:00';
    }

    document.querySelector("#reset_timer").addEventListener('click', this.reset_timer.bind(this));

    function increment_timers() {
      [].forEach.call(document.querySelectorAll(".updated-timer"), function(timer) {
        if(timer.dataset.started_at) {
          let now = moment().unix();
          let start_time = parseInt(timer.dataset.started_at);
          timer.innerText = moment.duration(now - start_time, 's').format("hh:mm:ss", { trim: false });
        } else {
          let previous_time = moment.duration(timer.innerText);
          timer.innerText = previous_time.add(1, 's').format("hh:mm:ss", { trim: false });
        }
      });
    }

    setInterval(increment_timers, 1000);
  </script>
</html>
